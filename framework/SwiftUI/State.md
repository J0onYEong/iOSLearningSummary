# OverView

State프로퍼티 랩퍼는 일반적인 프로퍼티 랩퍼와는 다르게 동작한다. 

일반적으로 모든 프로퍼티 랩퍼들은 wrappedValue라는 프로퍼티를 기본적으로 가진다.

해당 프로퍼티에 접근하기 위해서 원래는 인스턴스 앞에 언더바를 붙여 접근할 수 있다.

하지만 SwiftUI는 해당 과정을 생략하는 것을 가능하게 한다.

State구조체는 선언시에 초기화 하는 것을 SwiftUI는 권장한다. 

애초에 **private**키워드를 사용하는 것을 권장하여 멤버와이즈 생성자에서 초기화 하지 못하도록 하는 것을 권장한다.

State구조체 인스턴스는 SwiftUI에 의해서 별도의 storage에 저장되어 관리된다. 

정확한 이유는 명시되어 있지 않지만 이니셜러이져에서 wrappedValue를 초기화 하는 것은 이 프로세스와 맞지않은 동작이라고 doc에는 명시되어 있다.

- 생성자에서 초기화하여도 특별한 문제가 일어나지는 않지만 그렇다고 한다.

# View reloading

SwiftUI는 State구조체 인스턴스를 특별한 저장공간에 저장하여 관리한다고 하였다.

SwiftUI는 해당 인스턴스의 **wrappedValue가** 변하게 되는 경우 특정조건 안에 해당 프로퍼티가 선언된 뷰의 body프로퍼티를 재호출한다.

- 해당 프로퍼티가 서브 뷰에게 전달(생성자 매개변수)되는 경우
	- 뷰에 직접적인 변화를 주지 않아도 body가 재호출된다.


body프로퍼티가 재호출되는 경우 모든 서브뷰들이 재생성되며 이니셜라이저가 호출된다.

그럼 여기서 의문이 드는 것이 서브뷰의 State프로퍼티은 새로운 프로퍼티를 할당받는 것인가?

결과는 아니라는 것이다. 

서브뷰의 생성자에 해당프로퍼티의 초기화 코드가 있다 하더라도 **State프로퍼티에 인스턴스가 재할당 되지 않는다.**

아래코드의 경우 최초로 뷰가 선언될 때 15로 값이 설정된다.

SomeSubView인스턴스가 **재생성 되어도 아래코드의 프로퍼티 값은 15로도 1로도 초기화 되지 않는다.**

```Swift
struct SomeSubView: View {

    @State private var someState = 1

    init() {

        _someState = State(initialValue: 15)
        
    }
```


# StateObject, ObservedObject

앞서 State에 관해서 설명하였다.

SwiftUI는 State프로퍼티가 수정될 시에 발생하는 **copy-on-write매커니즘**을 통해 값이 변경되었음을 인지한다.

참조타입의 경우 해당 매커니즘이 없어 값이 수정되어도 SwiftUI는 이를 인지하지 못한다.

그래서 참조타입의 경우 StateObject, ObservedObject랩퍼를 사용하여야 변화를 감지할 수 있다.

두 랩퍼는 명확한 차이점을 가지고 있다.

StateObject의 경우 한번 인스턴스를 할당하면 State처럼 **재할당이 발생하지 않고 인스턴스 상태가 유지**된다.

반면에 ObservedObject의 경우 뷰재호출이 발생하면 **새로운 인스턴스가 생성되게 되고 모든 프로퍼티 값이 초기화된다.**
